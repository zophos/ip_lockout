#!/usr/bin/ruby
#
# Detect break-in attemption and block them
#
# Time-stamp: <2017-07-23 12:11:57 zophos>
#
# USAGE:
#   ip_lockout
#      or
#   check-ip_lockout (dry-run; shold be hard link)
#
# NOTE:
#   This script requires root privilege to read logs and exec iptables.
#
require 'time'
require 'ipaddr'

########################################################################
#
# load configration file
#
CONFIG_PATH=[
    ".ip_lockoutrc",
    "#{ENV['HOME']}/.ip_lockoutrc",
    "/usr/local/etc/ip_lockout/ip_lockout.rc",
    "/usr/local/etc/ip_lockout.rc",
    "/etc/ip_lockout/ip_lockout.rc",
    "/etc/ip_lockout.rc"
]

CONFIG_PATH.each{|rc|
    if(File.exist?(rc))
        load rc
        break
    end
}

########################################################################
#
# set default values
#
IPTABLES='/sbin/iptables' unless defined?(IPTABLES)
IPTABLES_TARGET='REJECT' unless defined?(IPTABLES_TARGET)
IPTABLES_PROT='all' unless defined?(IPTABLES_PROT)

# REPORT_IPTABLES_ACTIION=true

DB='/var/lib/ip_lockout/lockout.db' unless defined?(DB)


INSPECT_SPAN= 86400 unless defined?(INSPECT_SPAN) # 24h
LOCKOUT_SPAN= 28800 unless defined?(LOCKOUT_SPAN) # 8h

NUM_THRESHOLD=8 unless defined?(NUM_THRESHOLD)

AGGREGATE_MASK=24 unless defined?(AGGREGATE_MASK)
REAGGREGATE_THRESHOLD=1.25 unless defined?(REAGGREGATE_THRESHOLD)


WHITE_LIST=[] unless defined?(WHITE_LIST)

WHITE_LIST_ADDRS=WHITE_LIST.map{|a|
    IPAddr.new(a)
}

INSPECTOR={} unless defined?(INSPECTOR)

warn 'No inspector is defined' if INSPECTOR.empty?


########################################################################
#
# monkey-patch for CIDR mask
#
# from https://stackoverflow.com/questions/41604782/ruby-ipaddr-find-address-mask
#
class IPAddr
    def cidr_mask
        case (@family)
        when Socket::AF_INET
            32-Math.log2((1<<32)-@mask_addr).to_i #

        when Socket::AF_INET6
            128-Math.log2((1<<128)-@mask_addr).to_i #

        else
            raise AddressFamilyError, "unsupported address family"
        end
    end

    def to_s_with_mask(always_with_mask=nil)
        mask=self.cidr_mask
        if(always_with_mask ||
           (@family==Socket::AF_INET && mask<32) ||
           (@family==Socket::AF_INET6 && mask<128))
            "#{self.to_s}/#{self.cidr_mask}"
        else
            self.to_s
        end
    end
end


########################################################################
#
# Log inspection and blocking
#
class Blocker
    class Countor
        #
        # Countor item for each IP address
        #
        class Host
            TIME_ORIGIN=Time.at(0)

            def initialize(addr,last=TIME_ORIGIN,count=0)
                @addr=addr
                @last=last
                @count=count
                @tags=[]
            end
            attr_reader :addr,:last,:count,:tags

            def count_up(last,count=1)
                @last=last if @last<last
                @count+=count
            end

            def add_tag(tag)
                @tags.push(tag)
                @tags.uniq!
                @tags.compact!
            end

            def select
                yield(self)
            end

            def descript(port=$stdout)
                bullet=if(@count>=NUM_THRESHOLD)
                           '> '
                       else
                           '  '
                       end
                port<< "#{bullet}#{@addr.to_s_with_mask}: "<<
                    "#{@last.to_s} (#{@count} #{@tags.inspect})\n"
            end
        end
        #
        # end of Blocker::Countor::Host
        #

        #
        # Aggregated item for each subnet
        #
        class Subnet<Host
            def initialize(host,mask)
                super(host.addr.mask(mask))
                @mask=mask
                @hosts=[]
            end
            attr_reader :mask,:hosts

            def add_host(host)
                return nil unless @addr.include?(host.addr)

                @hosts.push(host)
                self.count_up(host.last,host.count)

                @tags+=host.tags
                @tags.sort!
                @tags.uniq!
                @tags.compact!

                self
            end
            def remove_host(host)
                return nil unless @addr.include?(host.addr)

                if(@hosts.delete(host))
                    @count-=host.count
                end
                host
            end

            def select(&block)
                raise 'no block given' unless block

                s=@hosts.select{|c|
                    c.select(&block)
                }
                case s.size
                when 0
                    self if yield(self)
                when 1
                    s[0]
                else
                    self
                end
            end

            def descript(port=$stdout)
                bullet=''
                if(@hosts.size>1)
                    bullet='    '
                    super
                end
                @hosts.sort_by{|a| a.last }.each{|c|
                    port<< bullet
                    c.descript(port)
                }
            end
        end
        #
        # end of Blocker::Countor::Subnet
        #

        #
        # Blocker::Countor
        #
        def initialize
            @hosts={}
            @subnets={}
        end
        def reg(a,t,tag=nil)
            @hosts[a]||=Host.new(a)
            @hosts[a].count_up(t)
            @hosts[a].add_tag(tag)
        end
        def aggregate
            @subnets={}
            @hosts.values.each{|h|
                addr=h.addr.mask(AGGREGATE_MASK)
                @subnets[addr]||=
                    Subnet.new(h,AGGREGATE_MASK)
                @subnets[addr].add_host(h)
            }

            @subnets
        end
        def select(force_aggregate=nil,&block)
            raise 'no block given' unless block

            self.aggregate if force_aggregate || @subnets.empty?

            @subnets.values.map{|sn|
                sn.select(&block)
            }.compact
        end

        def [](x)
            addr=if(x.respond_to?(:addr))
                     x.addr
                 else
                     x
                 end
            @subnets[addr]||@hosts[addr]
        end
        def delete(x)
            addr=if(x.respond_to?(:addr))
                     x.addr
                 else
                     x
                 end
            if(@subnets[addr])
                @subnets[addr].hosts.each{|h|
                    @hosts.delete(h)
                }
                @subnets.delete(addr)
            else
                h=@hosts.delete(addr)
                sn=self.subnet(h)
                if(sn.hosts.size<=1)
                    @subnets.delete(sn.addr)
                else
                    sn.remove_host(h)
                end
            end
        end

        def subnet(x)
            addr=if(x.respond_to?(:addr))
                     x.addr
                 else
                     x
                 end
            p_addr=addr.mask(AGGREGATE_MASK)
            @subnets[p_addr] unless addr==p_addr
        end

        def descript(port=$stdout)
            @subnets.values.sort_by{|sn| sn.last}.each{|sn|
                sn.descript(port)
            }
        end
    end
    #
    # end of Blocker::Countor
    #

    #
    # DB entries
    #
    class Entry<Countor::Host
        @@now=Time.now
        def self.now=(x)
            @@now=x
        end
        def initialize(addr,
                       last=TIME_ORIGIN,
                       count=0,
                       status=:new,
                       remain=nil,
                       updated=nil)
            super(addr,last,count)
            @status=status
            @remain=remain||@count
            @updated=updated||@@now
        end
        attr_reader :status,:remain,:updated

        def begin_block
            @status=:blocked
            @remain=@count
            @updated=@@now
            self
        end

        def count_down(c)
            @updated=@@now
            @remain-=c
            if(@remain<=0)
                @remain=0
                @status=:expired
                self
            else
                nil
            end
        end

        def force_expire
            @updated=@@now
            @status=:force_expire
        end

        def expire?
            @status==:expired
        end

        def reblock(h)
            @updated=@@now
            @last=h.last
            @count+=h.count
            @remain=@count
            @status=:new if @status==:expired
            self
        end

        def descript(port=$stdout)
            port<< "#{@addr.to_s_with_mask}: #{@last.to_s} (#{@count})\n"<<
                "  [#{@status} (remain: #{remain}) #{@updated}]\n"
        end
    end
    #
    # end of Blocker::Entry
    #


    HALF_THRESHOLD=
        NUM_THRESHOLD>2 ? NUM_THRESHOLD/2 : 1
    def initialize
        @now=if(defined?(FORCE_TIME_NOW_TO))
                 FORCE_TIME_NOW_TO
             else
                 Time.now
             end
        Entry.now=@now

        @countor=Countor.new

        @ignore_before=@now-INSPECT_SPAN
        @expire_at=@now-LOCKOUT_SPAN

        @records=[]
        _read_db

        @iptables=[]
        _read_iptables
    end

    def reg(addr,timestamp,tag=nil)
        a=IPAddr.new(addr)
        t=Time.parse(timestamp)

        return if WHITE_LIST_ADDRS.find{|w| w.include?(a) }

        @countor.reg(a,t,tag) if @ignore_before<t
    end

    def update
        @countor.aggregate
        @records.each{|r|
            sn=@countor.subnet(r)
            h=@countor[r]
            if(sn &&
               sn.last>r.last &&
               sn.count>HALF_THRESHOLD)
                sn.count_up(r.last,r.count)
                r.force_expire
            elsif(h)
                r.reblock(h) if(h.last>r.last &&
                    h.count>HALF_THRESHOLD)
                @countor.delete(h)
            end
        }

        @countor.select{|h|
            h.count>NUM_THRESHOLD
        }.map{|h|
            #
            # re-aggregate a host that has numerous count with
            # other hosts those have few count
            #
            sn=@countor.subnet(h)
            if(sn && h.count*REAGGREGATE_THRESHOLD<sn.count)
                sn
            else
                h
            end
        }.uniq.each{|h|
            @records.push(Entry.new(h.addr,h.last,h.count))
        }
    end

    def run(port=nil)
        self.update

        buf=[]
        @records.delete_if{|r|
            case r.status
            when :new
                r.begin_block
                buf.push(['I',r])
                nil
            when :blocked
                if(@expire_at>r.updated)
                    r.count_down(NUM_THRESHOLD)

                    if(r.expire? &&
                       @iptables.find{|e| e.addr.include?(r.addr) })
                        buf.push(['D',r])
                    end
                elsif(!@iptables.find{|e| e.addr.include?(r.addr) })
                    buf.push(['I',r])
                end
                nil
            when :force_expire
                buf.push(['D',r])
            when :expired
                r.updated<@ignore_before
            end
        }

        #
        # store DB if NOT dry-run
        #
        _write_db unless port

        buf.each{|(op,rec)|
            addr=rec.addr.to_s_with_mask

            if(defined?(REPORT_IPTABLES_ACTIION) &&
                    REPORT_IPTABLES_ACTIION)
                if(op=='I')
                    $stderr<< "#{@now.to_s}: block #{addr}. (#{rec.count})\n"
                else
                    $stderr<< "#{@now.to_s}: #{addr} #{rec.status}\n"
                end
            end

            _exec_iptables(op,addr,port)
        }
    end

    def descript(port=$stdout)
        port<< "DB:\n"
        @records.each{|r|
            r.descript(port)
        }
        port<< "\n"

        @countor.aggregate
        port<< "LOG:\n"
        @countor.descript(port)
        port<< "\n"

        self.run(port)

        port<< "----\n"
        @records.each{|r|
            r.descript(port)
        }
        port<< "\n\n"
    end

    private
    def _read_db
        if(File.exist?(DB))
            File.open(DB){|f|
                f.flock(File::LOCK_EX)
                @records=Marshal.load(f.read)
            }
        end
    end

    def _write_db
        File.open(DB,'w'){|f|
            f.flock(File::LOCK_EX)
            f<< Marshal.dump(@records)
        }
    end

    def _read_iptables
        @iptables.clear

        IO.popen([IPTABLES,'-L','INPUT','-n']){|io|
            io.each{|line|
                (target,prot,opt,src,dst,)=line.strip.split(/\s+/,6)
                if(target==IPTABLES_TARGET && prot==IPTABLES_PROT)
                    @iptables.push(Entry.new(IPAddr.new(src)))
                end
            }
        }
    end

    def _exec_iptables(op,addr,port=nil)
        cmd=[IPTABLES,
             "-#{op}",
             'INPUT',
             '-s',
             addr,
             '-j',
             IPTABLES_TARGET]
        if(port)
            port<< cmd.join(' ')<< "\n"
        else
            IO.popen(cmd,'r'){|io|
                $stderr<< io.read
            }
        end
    end
end


blocker=Blocker.new

#
# inspect each log
#
INSPECTOR.each{|log_file,hooks|
    File.foreach(log_file){|line|
        hooks.each{|tag,(re,addrhook)|
            m=line.match(re)
            if(m)
                addr=addrhook.call(line,m)
                if(addr)
                    timestamp=line.strip.split(/\s+/)[0..2].join(' ')
                    blocker.reg(addr,timestamp,tag)
                else
                    warn 'SKIP: could not find IP addr'
                end
            end
        }
    }
}


if(ARGV[0]=~/^-d/ || File.basename($0)=~/^check-/)
    #
    # dry-run
    #
    blocker.descript
else
    #
    # exec iptables
    #
    blocker.run
end
